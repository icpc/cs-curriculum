<html>
<title>Week 1 - Introduction</title>
<body>
<h1>Week 1 - Introduction</h1>
<hr>
<font color=red>Required reading for this week.  Competitive Programmer's 
Handbook: Chapter 1</font>
<hr>
Some basic skills required to be a good competitive programmer include (but are not
limited to):
<ul>
<li> Problem understanding: Do I even know what the problem is asking for?
<blockquote>
If you do not understand what the problem is asking to solve, none of the other skills
will help much.  Doing lots of problems can help with this skill since repetition
can build bridges to similar problems/solutions.
</blockquote>
<li> Problem recognition: What is the solution to the stated problem (duh)
<blockquote>
Once the problem is understood, do you know (or can you formulate) an algorithm
that will produce the desired solution?  Here, again, practice with similar problems
can help bridge the gap to understand how to attack a problem.  Classes like
Data Structures and Analysis of Algorithms can also help with this skill.
</blockquote>
<li> Problem ranking: How hard is the solution to the problem.
<blockquote>
I can name that tune is a pitfall many programmers / computer scientists can 
fall into where the initial analysis misses key details that make the problem 
much harder (or much easier) than the initial assessment might lead one to 
believe.  Practice builds this skill.
</blockquote>
<li> Problem ordering: Given a number of problems, put them in order, easiest 
to hardest
<blockquote>
In the competition setting, it's important to solve easy problems first.  Due 
to the way scoring is calculated, time spent on problems is accumulated from 
the start of the contest, not based on the last solution so solving the easy 
problems first, and quickly can mean the difference in 6th vs 11th place if 
all teams solve the same number of problems.
</blockquote>
<li> Problem sizing: Given input, memory, and time constraints, filter possible
solutions by the upper bound complexity of the algorithm
<blockquote>
Problem input ranges / constraints can give vital clues as to what sort of 
solution or algorithm will be necessary to successfully complete a problem.  
If you understand the problem, code it up to pass the example input files, but 
see that if the maxiumum problem set is presented, your solution won't complete
in the given time, it's not useful to submit the solution.  Go back, analyze 
your solution and try to find an algorithm of lower complexity.
</blockquote>
<li> Time estimation: How long will it take to implement the solution to the 
stated problem.
<blockquote>
You may have two equally trivial problems to solve.  One might require 15 lines
of code but the other requires 100 lines of code.  The shorter one is the one 
to do first. This is simplistic but you need to also be able to estimate 
development time in terms of typing, testing, and debugging into your 
consideration as to which problems to do when.
</blockquote>
</ul>
<pre>
https://open.kattis.com/problems/eulerianpath
https://open.kattis.com/problems/addingwords
https://open.kattis.com/problems/reversebinary
https://open.kattis.com/problems/anothercandies
https://open.kattis.com/problems/joylessgame
https://open.kattis.com/problems/compiler
https://open.kattis.com/problems/quadrant
https://open.kattis.com/problems/mali
https://open.kattis.com/problems/abc
https://open.kattis.com/problems/justaminute
https://open.kattis.com/problems/2048
https://open.kattis.com/contests/z3nkbs/problems/perica
https://open.kattis.com/contests/svdr92/problems/showroom
https://open.kattis.com/contests/f26ey4/problems/narrowartgallery
https://open.kattis.com/contests/f26ey4/problems/walrusweights
https://open.kattis.com/problems/sretan
https://open.kattis.com/problems/poklon
https://open.kattis.com/problems/hothike
https://open.kattis.com/contests/du8cd9/problems/bread
https://open.kattis.com/problems/basicinterpreter
</pre>
<b>After</b> you've analyzed, ranked, and ordered the above problems.  Spend
<u>at least</u> six hours solving them in your solve order.  Keep track of
how long you spent coding the problem up, testing, and debugging it to get to
an accepted solution.  Keep good records!  It's important to gather relevant
data concerning your perceptions and reality in order to refine your skills!
</body>
</html>
